// libquorum interface for Rust
// Copyright (c) 2021 Red Hat, Inc.
//
// All rights reserved.
//
// Author: Christine Caulfield (ccaulfi@redhat.com)
//


// For the code generated by bindgen
extern crate rust_corosync_sys as ffi;
use rust_corosync_sys::quorum::quorum_model_data_t;

use std::os::raw::{c_void, c_int};
use std::slice;
use std::collections::HashMap;
use std::sync::Mutex;
use crate::{CsError, DispatchFlags, TrackFlags, Result};
use crate::cs_error_to_enum;

#[derive(Copy, Clone)]
pub enum ModelData {
    ModelNone,
    ModelV1 (Model1Data)
}

pub enum QuorumType {
    Free,
    Set
}

#[derive(Copy, Clone)]
pub enum Model1Flags {
    None,
}

/// RingId returned by quorum_notification_fn
pub struct RingId {
    pub nodeid: u32,
    pub seq: u64,
}

// Used to convert a QUORUM handle into one of ours
lazy_static! {
    static ref HANDLE_HASH: Mutex<HashMap<u64, Handle>> = Mutex::new(HashMap::new());
}

fn list_to_vec(list_entries: u32, list: *const u32) -> Vec<u32>
{
    let mut r_member_list = Vec::<u32>::new();
    let temp_members: &[u32] = unsafe { slice::from_raw_parts(list, list_entries as usize) };
    for i in 0..list_entries as usize {
	r_member_list.push(temp_members[i]);
    }
    r_member_list
}


// Called from quorum callback function - munge params back to Rust from C
extern "C" fn rust_quorum_notification_fn(
    handle: ffi::quorum::quorum_handle_t,
    quorate: u32,
    ring_id: ffi::quorum::quorum_ring_id,
    member_list_entries: u32,
    member_list: *const u32)
{
    match HANDLE_HASH.lock().unwrap().get(&handle) {
	Some(h) =>  {
	    let r_ring_id = RingId{nodeid: ring_id.nodeid,
				   seq: ring_id.seq};
	    let r_member_list = list_to_vec(member_list_entries, member_list);
	    let r_quorate = match quorate {
		0 => false,
		1 => true,
		_ => false,
	    };
	    match &h.model_data {
		ModelData::ModelV1(md) =>
		    (md.quorum_notification_fn)(handle,
						r_quorate,
						r_ring_id,
						r_member_list),
		_ => {}
	    }
	}
	None => {}
    }

}


extern "C" fn rust_nodelist_notification_fn(
    handle: ffi::quorum::quorum_handle_t,
    ring_id: ffi::quorum::quorum_ring_id,
    member_list_entries: u32,
    member_list: *const u32,
    joined_list_entries: u32,
    joined_list: *const u32,
    left_list_entries: u32,
    left_list: *const u32)
{
    match HANDLE_HASH.lock().unwrap().get(&handle) {
	Some(h) =>  {
	    let r_ring_id = RingId{nodeid: ring_id.nodeid,
				   seq: ring_id.seq};

	    let r_member_list = list_to_vec(member_list_entries, member_list);
	    let r_joined_list = list_to_vec(joined_list_entries, joined_list);
	    let r_left_list = list_to_vec(left_list_entries, left_list);

	    match &h.model_data {
		ModelData::ModelV1(md) =>
		    (md.nodelist_notification_fn)(handle,
						  r_ring_id,
						  r_member_list,
						  r_joined_list,
						  r_left_list),
		_ => {}
	    }
	}
	None => {}
    }

}

#[derive(Copy, Clone)]
pub struct Model1Data {
    pub flags: Model1Flags,
    pub quorum_notification_fn: fn(hande: u64,
				   quorate: bool,
				   ring_id: RingId,
				   member_list: Vec<u32>),
    pub nodelist_notification_fn: fn(hande: u64,
				     ring_id: RingId,
				     member_list: Vec<u32>,
				     joined_list: Vec<u32>,
				     left_list: Vec<u32>),
}

// Our internal state
//#[derive(Copy, Clone)]
struct Handle {
    _quorum_handle: u64, // We *might* need this??
    model_data: ModelData,
}

/// Initialize a connection to the quorum subsystem
/// model_data: The type of initialization, and callbacks
/// context:  arbitrary value returned in callbacks
/// Returns a handle into the quorum library, and the quorum type (Free, or Set)
pub fn initialize(model_data: &ModelData, context: u64) -> Result<(u64, QuorumType)>
{
    let mut handle: ffi::quorum::quorum_handle_t = 0;
    let mut quorum_type: u32 = 0;

    let mut m = match model_data {
	ModelData::ModelV1(_v1) => {
	    ffi::quorum::quorum_model_v1_data_t {
		model: ffi::quorum::QUORUM_MODEL_V1,
		quorum_notify_fn: Some(rust_quorum_notification_fn),
		nodelist_notify_fn: Some(rust_nodelist_notification_fn),
	    }
	}
	// Only V1 supported. No point in doing legacy stuff in a new binding
	_ => return Err(CsError::CsErrInvalidParam)
    };

    handle =
	unsafe {
	    let c_context: *mut c_void = &mut &context as *mut _ as *mut c_void;
	    let c_model:   *mut quorum_model_data_t = &mut m as *mut _ as *mut quorum_model_data_t;
	    let res = ffi::quorum::quorum_model_initialize(&mut handle,
							   m.model,
							   c_model,
							   &mut quorum_type,
							   c_context);

	    if res == ffi::quorum::CS_OK {
		let rhandle = Handle{_quorum_handle: handle, model_data: *model_data};
		HANDLE_HASH.lock().unwrap().insert(handle, rhandle);
		handle
	    } else {
		return Err(cs_error_to_enum(res))
	    }
	};

    let quorum_type =
	match quorum_type {
	    0 => QuorumType::Free,
	    1 => QuorumType::Set,
	    _ => QuorumType::Set,
	};
    Ok((handle, quorum_type))
}


/// Finish with a connection to corosync
/// handle: a quorum handle as returned from [initialize]
pub fn finalize(handle: u64) -> Result<()>
{
    HANDLE_HASH.lock().unwrap().remove(&handle);
    let res =
	unsafe {
	    ffi::quorum::quorum_finalize(handle)
	};
    if res == ffi::quorum::CS_OK {
	Ok(())
    } else {
	Err(cs_error_to_enum(res))
    }
}

// Not sure if an FD is the right thing to return here, but it will do for now.
/// Return a file descriptor to use for poll/select on the QUORUM handle
/// handle: quorum handle from [initialize]
/// return: file descriptor
pub fn fd_get(handle: u64) -> Result<i32>
{
    let c_fd: *mut c_int = &mut 0 as *mut _ as *mut c_int;
    let res =
	unsafe {
	    ffi::quorum::quorum_fd_get(handle, c_fd)
	};
    if res == ffi::quorum::CS_OK {
	Ok(c_fd as i32)
    } else {
	Err(cs_error_to_enum(res))
    }
}


/// Display any/all active QUORUM callbacks
/// handle: a quorum handle as returned from [initialize]
/// flags: [DispatchFlags]
pub fn dispatch(handle: u64, flags: DispatchFlags) -> Result<()>
{
    let res =
	unsafe {
	    ffi::quorum::quorum_dispatch(handle, flags as u32)
	};
    if res == ffi::quorum::CS_OK {
	Ok(())
    } else {
	Err(cs_error_to_enum(res))
    }
}

/// Return a file descriptor to use for poll/select on the QUORUM handle
/// handle: quorum handle from [initialize]
/// return: boolean: true for quorate, false for inquorate
pub fn getquorate(handle: u64) -> Result<bool>
{
    let c_quorate: *mut c_int = &mut 0 as *mut _ as *mut c_int;
    let (res, r_quorate) =
	unsafe {
	    let res = ffi::quorum::quorum_getquorate(handle, c_quorate);
	    let r_quorate : i32 = *c_quorate;
	    (res, r_quorate)
	};
    if res == ffi::quorum::CS_OK {
	match r_quorate {
	    0 => Ok(false),
	    1 => Ok(true),
	    _ => Err(CsError::CsErrLibrary),
	}
    } else {
	Err(cs_error_to_enum(res))
    }
}

/// Track node and quorum changes
/// handle: a quorum handle as returned from [initialize]
/// flags: [TrackFlags]
pub fn trackstart(handle: u64, flags: TrackFlags) -> Result<()>
{
    let res =
	unsafe {
	    ffi::quorum::quorum_trackstart(handle, flags as u32)
	};
    if res == ffi::quorum::CS_OK {
	Ok(())
    } else {
	Err(cs_error_to_enum(res))
    }
}

/// Stop tracking node and quorum changes
/// handle: a quorum handle as returned from [initialize]
pub fn trackstop(handle: u64) -> Result<()>
{
    let res =
	unsafe {
	    ffi::quorum::quorum_trackstop(handle)
	};
    if res == ffi::quorum::CS_OK {
	Ok(())
    } else {
	Err(cs_error_to_enum(res))
    }
}

/// Get the current 'context' value for this handle
/// The context value is an arbitrary value that is always passed
/// back to callbacks to help identify the source
/// handle: a quorum handle as returned from [initialize]
pub fn context_get(handle: u64) -> Result<u64>
{
    let (res, context) =
	unsafe {
	    let mut context : u64 = 0;
	    let  c_context: *mut c_void = &mut context as *mut _ as *mut c_void;
	    let r = ffi::quorum::quorum_context_get(handle, c_context as *mut *const c_void);
	    (r, context)
	};
    if res == ffi::quorum::CS_OK {
	Ok(context)
    } else {
	Err(cs_error_to_enum(res))
    }
}

/// Set the current 'context' value for this handle
/// The context value is an arbitrary value that is always passed
/// back to callbacks to help identify the source.
/// Normally this is set in [initialize], but this allows it to be changed
/// handle: a quorum handle as returned from [initialize]
pub fn context_set(handle: u64, context: u64) -> Result<()>
{
    let res =
	unsafe {
	    let c_context = context as *mut c_void;
	    ffi::quorum::quorum_context_set(handle, c_context)
	};
    if res == ffi::quorum::CS_OK {
	Ok(())
    } else {
	Err(cs_error_to_enum(res))
    }
}
