// libcmap interface for Rust
// Copyright (c) 2021 Red Hat, Inc.
//
// All rights reserved.
//
// Author: Christine Caulfield (ccaulfi@redhat.com)
//


// For the code generated by bindgen
extern crate rust_corosync_sys as ffi;

use std::os::raw::{c_void, c_int};
use std::collections::HashMap;
use std::sync::Mutex;
use std::ffi::{CString};
use num_enum::TryFromPrimitive;
use std::convert::TryFrom;
use std::ptr::copy_nonoverlapping;
use std::fmt;

// NOTE: size_of and TypeId look perfect for this
// to make a generic set() function, but requre that the
// parameter too all functions is 'static,
// which we can't work with
// Leaving this comment here in case that changes
//use core::mem::size_of;
//use std::any::TypeId;


use crate::{CsError, DispatchFlags, Result};
use crate::{cs_error_to_enum, string_from_bytes};

// Maps:
pub enum Map
{
    Icmap,
    Stats,
}

// Tracker types
bitflags! {
    pub struct TrackType: i32
    {
	const DELETE = 1;
	const MODIFY = 2;
	const ADD = 4;
	const PREFIX = 8;
    }
}

impl fmt::Display for TrackType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
	if self.contains(TrackType::DELETE) {
	    write!(f, "DELETE ")?
	}
	if self.contains(TrackType::MODIFY) {
	    write!(f, "MODIFY ")?
	}
	if self.contains(TrackType::ADD) {
	    write!(f, "ADD ")?
	}
	if self.contains(TrackType::PREFIX) {
	    write!(f, "PREFIX ")
	}
	else {
	    Ok(())
	}
    }
}

#[derive(Copy, Clone)]
pub struct Handle
{
    cmap_handle: u64,
}

#[derive(Copy, Clone)]
pub struct TrackHandle
{
    track_handle: u64,
    notify_callback: NotifyCallback,
}

// Used to convert CMAP handles into one of ours, for callbacks
lazy_static! {
    static ref TRACKHANDLE_HASH: Mutex<HashMap<u64, TrackHandle>> = Mutex::new(HashMap::new());
    static ref HANDLE_HASH: Mutex<HashMap<u64, Handle>> = Mutex::new(HashMap::new());
}

/// Initialize a connection to the cmap subsystem
/// map: which cmap "map" to use
/// Returns a handle into the cmap library
pub fn initialize(map: Map) -> Result<Handle>
{
    let mut handle: ffi::cmap::cmap_handle_t = 0;
    let c_map = match map {
	Map::Icmap => ffi::cmap::CMAP_MAP_ICMAP,
	Map::Stats => ffi::cmap::CMAP_MAP_STATS,
    };

    unsafe {
	let res = ffi::cmap::cmap_initialize_map(&mut handle,
						 c_map);
	if res == ffi::cmap::CS_OK {
	    let rhandle = Handle{cmap_handle: handle};
	    HANDLE_HASH.lock().unwrap().insert(handle, rhandle);
	    Ok(rhandle)
	} else {
	    Err(cs_error_to_enum(res))
	}
    }
}


/// Finish with a connection to corosync
/// handle: a cmap handle as returned from [initialize]
pub fn finalize(handle: Handle) -> Result<()>
{
    let res =
	unsafe {
	    ffi::cmap::cmap_finalize(handle.cmap_handle)
	};
    if res == ffi::cmap::CS_OK {
	HANDLE_HASH.lock().unwrap().remove(&handle.cmap_handle);
	Ok(())
    } else {
	Err(cs_error_to_enum(res))
    }
}

/// Return a file descriptor to use for poll/select on the CMAP handle
/// handle: cmap handle from [initialize]
/// return: file descriptor
pub fn fd_get(handle: Handle) -> Result<i32>
{
    let c_fd: *mut c_int = &mut 0 as *mut _ as *mut c_int;
    let res =
	unsafe {
	    ffi::cmap::cmap_fd_get(handle.cmap_handle, c_fd)
	};
    if res == ffi::cmap::CS_OK {
	Ok(c_fd as i32)
    } else {
	Err(cs_error_to_enum(res))
    }
}

/// Display any/all active CMAP callbacks
/// handle: a cmap handle as returned from [initialize]
/// flags: [DispatchFlags]
pub fn dispatch(handle: Handle, flags: DispatchFlags) -> Result<()>
{
    let res =
	unsafe {
	    ffi::cmap::cmap_dispatch(handle.cmap_handle, flags as u32)
	};
    if res == ffi::cmap::CS_OK {
	Ok(())
    } else {
	Err(cs_error_to_enum(res))
    }
}


/// Get the current 'context' value for this handle
/// The context value is an arbitrary value that is always passed
/// back to callbacks to help identify the source
/// handle: a cmap handle as returned from [initialize]
pub fn context_get(handle: Handle) -> Result<u64>
{
    let (res, context) =
	unsafe {
	    let mut context : u64 = 0;
	    let c_context: *mut c_void = &mut context as *mut _ as *mut c_void;
	    let r = ffi::cmap::cmap_context_get(handle.cmap_handle, c_context as *mut *const c_void);
	    (r, context)
	};
    if res == ffi::cmap::CS_OK {
	Ok(context)
    } else {
	Err(cs_error_to_enum(res))
    }
}

/// Set the current 'context' value for this handle
/// The context value is an arbitrary value that is always passed
/// back to callbacks to help identify the source.
/// Normally this is set in [initialize], but this allows it to be changed
/// handle: a cmap handle as returned from [initialize]
pub fn context_set(handle: Handle, context: u64) -> Result<()>
{
    let res =
	unsafe {
	    let c_context = context as *mut c_void;
	    ffi::cmap::cmap_context_set(handle.cmap_handle, c_context)
	};
    if res == ffi::cmap::CS_OK {
	Ok(())
    } else {
	Err(cs_error_to_enum(res))
    }
}

#[derive(Debug, Eq, PartialEq, TryFromPrimitive)]
#[repr(u32)]
pub enum DataType {
    Int8 = ffi::cmap::CMAP_VALUETYPE_INT8 as u32,
    UInt8 = ffi::cmap::CMAP_VALUETYPE_UINT8 as u32,
    Int16 = ffi::cmap::CMAP_VALUETYPE_INT16 as u32,
    UInt16 = ffi::cmap::CMAP_VALUETYPE_UINT16 as u32,
    Int32 = ffi::cmap::CMAP_VALUETYPE_INT32 as u32,
    UInt32 = ffi::cmap::CMAP_VALUETYPE_UINT32 as u32,
    Int64 = ffi::cmap::CMAP_VALUETYPE_INT64 as u32,
    UInt64 = ffi::cmap::CMAP_VALUETYPE_UINT64 as u32,
    Float = ffi::cmap::CMAP_VALUETYPE_FLOAT as u32,
    Double = ffi::cmap::CMAP_VALUETYPE_DOUBLE as u32,
    String = ffi::cmap::CMAP_VALUETYPE_STRING as u32,
    Binary = ffi::cmap::CMAP_VALUETYPE_BINARY as u32,
    Unknown = 999,
}

fn cmap_to_enum(cmap_type: u32) -> DataType
{
    match DataType::try_from(cmap_type) {
	Ok(e) => e,
	Err(_) => DataType::Unknown
    }
}

// Data returned from the cmap::get() call
pub enum Data {
    Int8(i8),
    UInt8(u8),
    Int16(i16),
    UInt16(u16),
    Int32(i32),
    UInt32(u32),
    Int64(i64),
    UInt64(u64),
    Float(f32),
    Double(f64),
    String(String),
    Binary(Vec<u8>),
    Unknown,
}

impl fmt::Display for DataType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
	match self {
	    DataType::Int8 => write!(f, "Int8"),
	    DataType::UInt8 => write!(f, "UInt8"),
	    DataType::Int16 => write!(f, "Int16"),
	    DataType::UInt16 => write!(f, "UInt16"),
	    DataType::Int32 => write!(f, "Int32"),
	    DataType::UInt32 => write!(f, "UInt32"),
	    DataType::Int64 => write!(f, "Int64"),
	    DataType::UInt64 => write!(f, "UInt64"),
	    DataType::Float => write!(f, "Float"),
	    DataType::Double => write!(f, "Double"),
	    DataType::String => write!(f, "String"),
	    DataType::Binary => write!(f, "Binary"),
	    DataType::Unknown => write!(f, "Unknown"),
	}
    }
}

impl fmt::Display for Data {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
	match self {
	    Data::Int8(v) => write!(f, "{} (Int8)", v),
	    Data::UInt8(v) => write!(f, "{} (UInt8)", v),
	    Data::Int16(v) => write!(f, "{} (Int16)", v),
	    Data::UInt16(v) => write!(f, "{} (UInt16)", v),
	    Data::Int32(v) => write!(f, "{} (Int32)", v),
	    Data::UInt32(v) => write!(f, "{} (UInt32)", v),
	    Data::Int64(v) => write!(f, "{} (Int64)", v),
	    Data::UInt64(v) => write!(f, "{} (UInt64)", v),
	    Data::Float(v) => write!(f, "{} (Float)", v),
	    Data::Double(v) => write!(f, "{} (Double)", v),
	    Data::String(v) => write!(f, "{} (String)", v),
	    Data::Binary(v) => write!(f, "{:?} (Binary)", v),
	    Data::Unknown => write!(f, "Unknown)"),
	}
    }
}

const CMAP_KEYNAME_MAXLENGTH : usize = 255;
fn string_to_cstring_validated(key: &String, maxlen: usize) -> Result<CString>
{
    if maxlen > 0 && key.len() >= maxlen {
	return Err(CsError::CsErrInvalidParam);
    }

    match CString::new(key.as_str()) {
	Ok(n) => Ok(n),
	Err(_) => Err(CsError::CsErrLibrary),
    }
}

fn set_value(handle: Handle, key_name: String, datatype: DataType, value: *mut c_void, length: usize) -> Result<()>
{
    let csname = string_to_cstring_validated(&key_name, CMAP_KEYNAME_MAXLENGTH)?;
    let res = unsafe {
	ffi::cmap::cmap_set(handle.cmap_handle, csname.as_ptr(), value, length, datatype as u32)
    };
    if res == ffi::cmap::CS_OK {
	Ok(())
    } else {
	Err(cs_error_to_enum(res))
    }
}

/// Sets a u8 value into cmap
/// handle: handle returned from [initialize]
/// key_name: must be a C-compatible string
/// value u8
/// I wanted to make a generic for this but the Rust functions
/// for getting a type in a generic function require the value
/// to be 'static, sorry
pub fn set_u8(handle: Handle, key_name: String, value: u8) -> Result<()>
{
    let mut tmp = value;
    let c_value: *mut c_void = &mut tmp as *mut _ as *mut c_void;
    set_value(handle, key_name, DataType::UInt8, c_value as *mut c_void, 1)
}

/// Sets an i8 value into cmap
/// handle: handle returned from [initialize]
/// key_name: must be a C-compatible string
/// value u8
pub fn set_i8(handle: Handle, key_name: String, value: i8) -> Result<()>
{
    let mut tmp = value;
    let c_value: *mut c_void = &mut tmp as *mut _ as *mut c_void;
    set_value(handle, key_name, DataType::Int8, c_value as *mut c_void, 1)
}

/// Sets a u16 value into cmap
/// handle: handle returned from [initialize]
/// key_name: must be a C-compatible string
/// value u16
pub fn set_u16(handle: Handle, key_name: String, value: u16) -> Result<()>
{
    let mut tmp = value;
    let c_value: *mut c_void = &mut tmp as *mut _ as *mut c_void;
    set_value(handle, key_name, DataType::UInt16, c_value as *mut c_void, 2)
}

/// Sets an i16 value into cmap
/// handle: handle returned from [initialize]
/// key_name: must be a C-compatible string
/// value u16
pub fn set_i16(handle: Handle, key_name: String, value: i16) -> Result<()>
{
    let mut tmp = value;
    let c_value: *mut c_void = &mut tmp as *mut _ as *mut c_void;
    set_value(handle, key_name, DataType::Int16, c_value as *mut c_void, 2)
}

/// Sets a u32 value into cmap
/// handle: handle returned from [initialize]
/// key_name: must be a C-compatible string
/// value u32
pub fn set_u32(handle: Handle, key_name: String, value: u32) -> Result<()>
{
    let mut tmp = value;
    let c_value: *mut c_void = &mut tmp as *mut _ as *mut c_void;
    set_value(handle, key_name, DataType::UInt32, c_value, 4)
}

/// Sets an i32 value into cmap
/// handle: handle returned from [initialize]
/// key_name: must be a C-compatible string
/// value u32
pub fn set_i132(handle: Handle, key_name: String, value: i32) -> Result<()>
{
    let mut tmp = value;
    let c_value: *mut c_void = &mut tmp as *mut _ as *mut c_void;
    set_value(handle, key_name, DataType::Int32, c_value as *mut c_void, 4)
}

/// Sets a u64 value into cmap
/// handle: handle returned from [initialize]
/// key_name: must be a C-compatible string
/// value u64
pub fn set_u64(handle: Handle, key_name: String, value: u64) -> Result<()>
{
    let mut tmp = value;
    let c_value: *mut c_void = &mut tmp as *mut _ as *mut c_void;
    set_value(handle, key_name, DataType::UInt64, c_value as *mut c_void, 8)
}

/// Sets an i64 value into cmap
/// handle: handle returned from [initialize]
/// key_name: must be a C-compatible string
/// value u64
pub fn set_i164(handle: Handle, key_name: String, value: i64) -> Result<()>
{
    let mut tmp = value;
    let c_value: *mut c_void = &mut tmp as *mut _ as *mut c_void;
    set_value(handle, key_name, DataType::Int64, c_value as *mut c_void, 8)
}

/// Sets a string value into cmap
/// handle: handle returned from [initialize]
/// key_name: must be a C-compatible string
/// value: String, but must also be C-compatible
pub fn set_string(handle: Handle, key_name: String, value: String) -> Result<()>
{
    let v_string =  string_to_cstring_validated(&value, 0)?;
    set_value(handle, key_name, DataType::String, v_string.as_ptr() as *mut c_void, value.len())
}

/// Sets a binary value into cmap
/// handle: handle returned from [initialize]
/// key_name: must be a C-compatible string
/// value: &[u8] of any length
pub fn set_binary(handle: Handle, key_name: String, value: &[u8]) -> Result<()>
{
    set_value(handle, key_name, DataType::String, value.as_ptr() as *mut c_void, value.len())
}


// Local function to parse out values from the C mess
// Assumes the c_value is complete. So cmap::get() will need to check the size
//   and re-get before calling us with a resized buffer
fn c_to_data(value_size: usize, c_key_type: u32, c_value: *const u8) -> Result<Data>
{
    unsafe {
	match cmap_to_enum(c_key_type) {
	    DataType::UInt8 => {
		let mut ints = [0u8; 1];
		copy_nonoverlapping(c_value as *mut u8, ints.as_mut_ptr() as *mut u8, value_size);
		Ok(Data::UInt8(ints[0]))
	    }
	    DataType::Int8 => {
		let mut ints = [0i8; 1];
		copy_nonoverlapping(c_value as *mut u8, ints.as_mut_ptr() as *mut u8, value_size);
		Ok(Data::Int8(ints[0]))
	    }
	    DataType::UInt16 => {
		let mut ints = [0u16; 1];
		copy_nonoverlapping(c_value as *mut u8, ints.as_mut_ptr() as *mut u8, value_size);
		Ok(Data::UInt16(ints[0]))
	    }
	    DataType::Int16 => {
		let mut ints = [0i16; 1];
		copy_nonoverlapping(c_value as *mut u8, ints.as_mut_ptr() as *mut u8, value_size);
		Ok(Data::Int16(ints[0]))
	    }
	    DataType::UInt32 => {
		let mut ints = [0u32; 1];
		copy_nonoverlapping(c_value as *mut u8, ints.as_mut_ptr() as *mut u8, value_size);
		Ok(Data::UInt32(ints[0]))
	    }
	    DataType::Int32 => {
		let mut ints = [0i32; 1];
		copy_nonoverlapping(c_value as *mut u8, ints.as_mut_ptr() as *mut u8, value_size);
		Ok(Data::Int32(ints[0]))
	    }
	    DataType::UInt64 => {
		let mut ints = [0u64; 1];
		copy_nonoverlapping(c_value as *mut u8, ints.as_mut_ptr() as *mut u8, value_size);
		Ok(Data::UInt64(ints[0]))
	    }
	    DataType::Int64 => {
		let mut ints = [0i64; 1];
		copy_nonoverlapping(c_value as *mut u8, ints.as_mut_ptr() as *mut u8, value_size);
		Ok(Data::Int64(ints[0]))
	    }
	    DataType::Float => {
		let mut ints = [0f32; 1];
		copy_nonoverlapping(c_value as *mut u8, ints.as_mut_ptr() as *mut u8, value_size);
		Ok(Data::Float(ints[0]))
	    }
	    DataType::Double => {
		let mut ints = [0f64; 1];
		copy_nonoverlapping(c_value as *mut u8, ints.as_mut_ptr() as *mut u8, value_size);
		Ok(Data::Double(ints[0]))
	    }
	    DataType::String => {
		let mut ints = Vec::<u8>::new();
		ints.resize(value_size, 0u8);
		copy_nonoverlapping(c_value as *mut u8, ints.as_mut_ptr() as *mut u8, value_size);
		// -1 here so CString doesn't see the NUL
		let cs = match CString::new(&ints[0..value_size-1 as usize]) {
		    Ok(c1) => c1,
		    Err(_) => return Err(CsError::CsErrLibrary),
		};
		match cs.into_string() {
		    Ok(s) => Ok(Data::String(s)),
		    Err(_) => return Err(CsError::CsErrLibrary),
		}
	    }
	    DataType::Binary => {
		let mut ints = Vec::<u8>::new();
		ints.resize(value_size, 0u8);
		copy_nonoverlapping(c_value as *mut u8, ints.as_mut_ptr() as *mut u8, value_size);
		Ok(Data::Binary(ints))
	    }
	    DataType::Unknown => {
		Ok(Data::Unknown)
	    }
	}
    }
}

/// cmap_get: get a value from cmap
/// handle: cmap handle from [initialize]
/// key_name: String name for the cmap key
/// returns a [Data] enum with the value
const INITIAL_SIZE : usize = 256;
pub fn get(handle: Handle, key_name: String) -> Result<Data>
{
    let csname = string_to_cstring_validated(&key_name, CMAP_KEYNAME_MAXLENGTH)?;
    let mut value_size : usize = 16;
    let mut c_key_type : u32 = 0;
    let mut c_value = Vec::<u8>::new();

    // First guess at a size for Strings and Binaries. Expand if needed
    c_value.resize(INITIAL_SIZE, 0u8);

    unsafe {
	let res = ffi::cmap::cmap_get(handle.cmap_handle, csname.as_ptr(), c_value.as_mut_ptr() as *mut c_void,
				      &mut value_size, &mut c_key_type);
	if res ==  ffi::cmap::CS_OK {

	    if value_size > INITIAL_SIZE {
		// Need to try again with a bigger buffer
		c_value.resize(value_size, 0u8);
		let res2 = ffi::cmap::cmap_get(handle.cmap_handle, csname.as_ptr(), c_value.as_mut_ptr() as *mut c_void,
					       &mut value_size, &mut c_key_type);
		if res2 != ffi::cmap::CS_OK {
		    return Err(cs_error_to_enum(res2));
		}
	    }

	    // Convert to Rust type and return as a Data enum
	    return c_to_data(value_size, c_key_type, c_value.as_ptr());
	} else {
	    return Err(cs_error_to_enum(res));
	}
    }
}

/// increment the value in a cmap key (must be a numeric type)
/// handle: a cmap handle as returned from [initialize]
/// key_name: Name of the key whose value is to be incremented, as a String
pub fn inc(handle: Handle, key_name: String) -> Result<()>
{
    let csname = string_to_cstring_validated(&key_name, CMAP_KEYNAME_MAXLENGTH)?;
    let res = unsafe {
	ffi::cmap::cmap_inc(handle.cmap_handle, csname.as_ptr())
    };
    if res == ffi::cmap::CS_OK {
	Ok(())
    } else {
	Err(cs_error_to_enum(res))
    }
}

/// decrement the value in a cmap key (must be a numeric type)
/// handle: a cmap handle as returned from [initialize]
/// key_name: Name of the key whose value is to be decremented, as a String
pub fn dec(handle: Handle, key_name: String) -> Result<()>
{
    let csname = string_to_cstring_validated(&key_name, CMAP_KEYNAME_MAXLENGTH)?;
    let res = unsafe {
	ffi::cmap::cmap_dec(handle.cmap_handle, csname.as_ptr())
    };
    if res == ffi::cmap::CS_OK {
	Ok(())
    } else {
	Err(cs_error_to_enum(res))
    }
}

// Callback for CMAP notify events from corosync, convert params to Rust and pass on.
extern "C" fn rust_notify_fn(cmap_handle: ffi::cmap::cmap_handle_t,
			     cmap_track_handle: ffi::cmap::cmap_track_handle_t,
			     event: i32,
			     key_name: *const ::std::os::raw::c_char,
			     new_value: ffi::cmap::cmap_notify_value,
			     old_value: ffi::cmap::cmap_notify_value,
			     user_data: *mut ::std::os::raw::c_void)
{
    // If cmap_handle doesn't match then throw away the callback.
    match HANDLE_HASH.lock().unwrap().get(&cmap_handle) {
	Some(r_cmap_handle) => {
	    match TRACKHANDLE_HASH.lock().unwrap().get(&cmap_track_handle) {
		Some(h) =>  {
		    let r_keyname = match string_from_bytes(key_name, CMAP_KEYNAME_MAXLENGTH) {
			Ok(s) => s,
			Err(_) => return,
		    };

		    let r_old = match c_to_data(old_value.len, old_value.type_, old_value.data as *const u8) {
			Ok(v) => v,
			Err(_) => return,
		    };
		    let r_new = match c_to_data(new_value.len, new_value.type_, new_value.data as *const u8) {
			Ok(v) => v,
			Err(_) => return,
		    };

		    (h.notify_callback.notify_fn)(r_cmap_handle, h, TrackType{bits: event},
						  &r_keyname,
						  &r_old, &r_new,
						  user_data as u64);
		}
		None => {}
	    }
	}
	None => {}
    }
}

#[derive(Copy, Clone)]
pub struct NotifyCallback
{
    pub notify_fn: fn(handle: &Handle,
		      track_handle: &TrackHandle,
		      event: TrackType,
		      key_name: &String,
		      new_value: &Data,
		      old_value: &Data,
		      user_data: u64),
}

/// track_start - track changes in cmap values
/// handle: handle returned from [initialize]
/// key_name: name of key or prefix of keys to track
/// track_type: Type of event to track for as [TrackType]
/// notify_callback: function to call when changes occur
/// user_data: value to pass to callback
/// Returns a track handle, used in [track_stop]
pub fn track_add(handle: Handle,
		 key_name: &String,
		 track_type: TrackType,
		 notify_callback: &NotifyCallback,
		 user_data: u64) -> Result<TrackHandle>
{
    let c_name = string_to_cstring_validated(&key_name, CMAP_KEYNAME_MAXLENGTH)?;
    let mut c_trackhandle = 0u64;
    let res =
	unsafe {
	    ffi::cmap::cmap_track_add(handle.cmap_handle, c_name.as_ptr(), track_type.bits, Some(rust_notify_fn), user_data as *mut c_void, &mut c_trackhandle)
	};
    if res == ffi::cmap::CS_OK {
	let rhandle = TrackHandle{track_handle: c_trackhandle, notify_callback: *notify_callback};
	TRACKHANDLE_HASH.lock().unwrap().insert(c_trackhandle, rhandle);
	Ok(rhandle)
    } else {
	Err(cs_error_to_enum(res))
    }
}

/// track_delete: Remove a tracker
/// handle: cmap handle from [intialize]
/// track_handle: tracker handle from [track_add]
pub fn track_delete(handle: Handle,
		    track_handle: TrackHandle)->Result<()>
{
    let res =
	unsafe {
	    ffi::cmap::cmap_track_delete(handle.cmap_handle, track_handle.track_handle)
	};
    if res == ffi::cmap::CS_OK {
	TRACKHANDLE_HASH.lock().unwrap().remove(&track_handle.track_handle);
	Ok(())
    } else {
	Err(cs_error_to_enum(res))
    }
}
