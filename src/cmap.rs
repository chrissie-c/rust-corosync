// libcmap interface for Rust
// Copyright (c) 2021 Red Hat, Inc.
//
// All rights reserved.
//
// Author: Christine Caulfield (ccaulfi@redhat.com)
//


// For the code generated by bindgen
extern crate rust_corosync_sys as ffi;

use std::os::raw::{c_void, c_int};
use std::collections::HashMap;
use std::sync::Mutex;
use std::ffi::{CString};
use num_enum::TryFromPrimitive;
use std::convert::TryFrom;
use std::ptr::copy_nonoverlapping;
use std::fmt;
//use core::mem::size_of;
//use std::any::{TypeId};


use crate::{CsError, DispatchFlags, Result};
//use crate::{CsError, DispatchFlags, TrackFlags, Result};
use crate::cs_error_to_enum;

// Maps:
pub enum Map
{
    Icmap,
    Stats,
}

// Tracker types
pub enum Track
{
    Add,
    Delete,
    Modify,
}

#[derive(Copy, Clone)]
pub struct Handle
{
    cmap_handle: u64,
}

// Used to convert a CMAP handle into one of ours
lazy_static! {
    static ref HANDLE_HASH: Mutex<HashMap<u64, Handle>> = Mutex::new(HashMap::new());
}

/// Initialize a connection to the cmap subsystem
/// map: which cmap "map" to use
/// Returns a handle into the cmap library
pub fn initialize(map: Map) -> Result<Handle>
{
    let mut handle: ffi::cmap::cmap_handle_t = 0;
    let c_map = match map {
	Map::Icmap => ffi::cmap::CMAP_MAP_ICMAP,
	Map::Stats => ffi::cmap::CMAP_MAP_STATS,
    };

    unsafe {
	let res = ffi::cmap::cmap_initialize_map(&mut handle,
						 c_map);
	if res == ffi::cmap::CS_OK {
	    let rhandle = Handle{cmap_handle: handle};
	    HANDLE_HASH.lock().unwrap().insert(handle, rhandle);
	    Ok(rhandle)
	} else {
	    Err(cs_error_to_enum(res))
	}
    }
}


/// Finish with a connection to corosync
/// handle: a cmap handle as returned from [initialize]
pub fn finalize(handle: Handle) -> Result<()>
{
    HANDLE_HASH.lock().unwrap().remove(&handle.cmap_handle);
    let res =
	unsafe {
	    ffi::cmap::cmap_finalize(handle.cmap_handle)
	};
    if res == ffi::cmap::CS_OK {
	Ok(())
    } else {
	Err(cs_error_to_enum(res))
    }
}

/// Return a file descriptor to use for poll/select on the CMAP handle
/// handle: cmap handle from [initialize]
/// return: file descriptor
pub fn fd_get(handle: Handle) -> Result<i32>
{
    let c_fd: *mut c_int = &mut 0 as *mut _ as *mut c_int;
    let res =
	unsafe {
	    ffi::cmap::cmap_fd_get(handle.cmap_handle, c_fd)
	};
    if res == ffi::cmap::CS_OK {
	Ok(c_fd as i32)
    } else {
	Err(cs_error_to_enum(res))
    }
}

/// Display any/all active CMAP callbacks
/// handle: a cmap handle as returned from [initialize]
/// flags: [DispatchFlags]
pub fn dispatch(handle: Handle, flags: DispatchFlags) -> Result<()>
{
    let res =
	unsafe {
	    ffi::cmap::cmap_dispatch(handle.cmap_handle, flags as u32)
	};
    if res == ffi::cmap::CS_OK {
	Ok(())
    } else {
	Err(cs_error_to_enum(res))
    }
}


/// Get the current 'context' value for this handle
/// The context value is an arbitrary value that is always passed
/// back to callbacks to help identify the source
/// handle: a cmap handle as returned from [initialize]
pub fn context_get(handle: Handle) -> Result<u64>
{
    let (res, context) =
	unsafe {
	    let mut context : u64 = 0;
	    let c_context: *mut c_void = &mut context as *mut _ as *mut c_void;
	    let r = ffi::cmap::cmap_context_get(handle.cmap_handle, c_context as *mut *const c_void);
	    (r, context)
	};
    if res == ffi::cmap::CS_OK {
	Ok(context)
    } else {
	Err(cs_error_to_enum(res))
    }
}

/// Set the current 'context' value for this handle
/// The context value is an arbitrary value that is always passed
/// back to callbacks to help identify the source.
/// Normally this is set in [initialize], but this allows it to be changed
/// handle: a cmap handle as returned from [initialize]
pub fn context_set(handle: Handle, context: u64) -> Result<()>
{
    let res =
	unsafe {
	    let c_context = context as *mut c_void;
	    ffi::cmap::cmap_context_set(handle.cmap_handle, c_context)
	};
    if res == ffi::cmap::CS_OK {
	Ok(())
    } else {
	Err(cs_error_to_enum(res))
    }
}

#[derive(Debug, Eq, PartialEq, TryFromPrimitive)]
#[repr(u32)]
pub enum DataType {
    Int8 = ffi::cmap::CMAP_VALUETYPE_INT8 as u32,
    UInt8 = ffi::cmap::CMAP_VALUETYPE_UINT8 as u32,
    Int16 = ffi::cmap::CMAP_VALUETYPE_INT16 as u32,
    UInt16 = ffi::cmap::CMAP_VALUETYPE_UINT16 as u32,
    Int32 = ffi::cmap::CMAP_VALUETYPE_INT32 as u32,
    UInt32 = ffi::cmap::CMAP_VALUETYPE_UINT32 as u32,
    Int64 = ffi::cmap::CMAP_VALUETYPE_INT64 as u32,
    UInt64 = ffi::cmap::CMAP_VALUETYPE_UINT64 as u32,
    Float = ffi::cmap::CMAP_VALUETYPE_FLOAT as u32,
    Double = ffi::cmap::CMAP_VALUETYPE_DOUBLE as u32,
    String = ffi::cmap::CMAP_VALUETYPE_STRING as u32,
    Binary = ffi::cmap::CMAP_VALUETYPE_BINARY as u32,
    Unknown = 999,
}

fn cmap_to_enum(cmap_type: u32) -> DataType
{
    match DataType::try_from(cmap_type) {
	Ok(e) => e,
	Err(_) => DataType::Unknown
    }
}

// Data returned from the cmap::get() call
pub enum Data {
    Int8(i8),
    UInt8(u8),
    Int16(i16),
    UInt16(u16),
    Int32(i32),
    UInt32(u32),
    Int64(i64),
    UInt64(u64),
    Float(f32),
    Double(f64),
    String(String),
    Binary(Vec<u8>),
    Unknown,
}

impl fmt::Display for DataType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
	match self {
	    DataType::Int8 => write!(f, "Int8"),
	    DataType::UInt8 => write!(f, "UInt8"),
	    DataType::Int16 => write!(f, "Int16"),
	    DataType::UInt16 => write!(f, "UInt16"),
	    DataType::Int32 => write!(f, "Int32"),
	    DataType::UInt32 => write!(f, "UInt32"),
	    DataType::Int64 => write!(f, "Int64"),
	    DataType::UInt64 => write!(f, "UInt64"),
	    DataType::Float => write!(f, "Float"),
	    DataType::Double => write!(f, "Double"),
	    DataType::String => write!(f, "String"),
	    DataType::Binary => write!(f, "Binary"),
	    DataType::Unknown => write!(f, "Unknown"),
	}
    }
}

impl fmt::Display for Data {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
	match self {
	    Data::Int8(v) => write!(f, "{} (Int8)", v),
	    Data::UInt8(v) => write!(f, "{} (UInt8)", v),
	    Data::Int16(v) => write!(f, "{} (Int16)", v),
	    Data::UInt16(v) => write!(f, "{} (UInt16)", v),
	    Data::Int32(v) => write!(f, "{} (Int32)", v),
	    Data::UInt32(v) => write!(f, "{} (UInt32)", v),
	    Data::Int64(v) => write!(f, "{} (Int64)", v),
	    Data::UInt64(v) => write!(f, "{} (UInt64)", v),
	    Data::Float(v) => write!(f, "{} (Float)", v),
	    Data::Double(v) => write!(f, "{} (Double)", v),
	    Data::String(v) => write!(f, "{} (String)", v),
	    Data::Binary(v) => write!(f, "{:?} (Binary)", v),
	    Data::Unknown => write!(f, "Unknown)"),
	}
    }
}



// This idea looks interesting but TypeId needs a 'static
// parameter type which is not really helpful to us.

// // Returns type & size for cmap functions
// fn cmap_data_type<T: 'static>(value: T) -> (DataType, usize)
// {
//     let typeid = TypeId::of::<T>();

//     // Can't use a match here as TypeId::of::<T>() is a fn call.
//     if typeid == TypeId::of::<i8>()  { (DataType::Int8, 1);}
//     if typeid == TypeId::of::<u8>()  { (DataType::UInt8, 1);}
//     if typeid == TypeId::of::<i16>() { (DataType::Int16, 2);}
//     if typeid == TypeId::of::<u16>() { (DataType::UInt16, 2);}
//     if typeid == TypeId::of::<i32>() { (DataType::Int32, 4);}
//     if typeid == TypeId::of::<u32>() { (DataType::UInt32, 4);}
//     if typeid == TypeId::of::<i64>() { (DataType::Int64, 8);}
//     if typeid == TypeId::of::<u64>() { (DataType::UInt64, 8);}
//     if typeid == TypeId::of::<String>() { (DataType::String, 0);}
//     if typeid == TypeId::of::<[u8]>() { (DataType::Binary, 0);}
// // TODO: Not sure what to do with BINARY or string yet
//     (DataType::Binary, 0)
// }


// /// Generic 'set' function
// /// Value to set, and error will be returned if it's not valid
// /// Strings should be 8-bit ASCII for C compatibility
// pub fn set<T: 'static>(value: T) -> Result<()>
// {
//     println!("size = {}", size_of::<T>() as usize);

//     let (typeid, size) = cmap_data_type(value);
//     if size == 0 {
// 	// Not current supported
// 	return Err(CsError::CsErrInvalidParam);
//     }
// // TODO

//     Ok(())
// }


const CMAP_KEYNAME_MAXLENGTH : usize = 255;
fn string_to_cstring_validated(key: &String, maxlen: usize) -> Result<CString>
{
    if maxlen > 0 && key.len() >= maxlen {
	return Err(CsError::CsErrInvalidParam);
    }

    match CString::new(key.as_str()) {
	Ok(n) => Ok(n),
	Err(_) => Err(CsError::CsErrLibrary),
    }
}

fn set_value(handle: Handle, key_name: String, datatype: DataType, value: *mut c_void, length: usize) -> Result<()>
{
    let csname = string_to_cstring_validated(&key_name, CMAP_KEYNAME_MAXLENGTH)?;
    let res = unsafe {
	ffi::cmap::cmap_set(handle.cmap_handle, csname.as_ptr(), value, length, datatype as u32)
    };
    if res == ffi::cmap::CS_OK {
	Ok(())
    } else {
	Err(cs_error_to_enum(res))
    }
}

/// Sets a u8 value into cmap
/// handle: handle returned from [initialize]
/// key_name: must be a C-compatible string
/// value u8
/// I wanted to make a generic for this but the Rust functions
/// for getting a type in a generic function require the value
/// to be 'static, sorry
pub fn set_u8(handle: Handle, key_name: String, value: u8) -> Result<()>
{
    let mut tmp = value;
    let c_value: *mut c_void = &mut tmp as *mut _ as *mut c_void;
    set_value(handle, key_name, DataType::UInt8, c_value as *mut c_void, 1)
}

/// Sets an i8 value into cmap
/// handle: handle returned from [initialize]
/// key_name: must be a C-compatible string
/// value u8
pub fn set_i8(handle: Handle, key_name: String, value: i8) -> Result<()>
{
    let mut tmp = value;
    let c_value: *mut c_void = &mut tmp as *mut _ as *mut c_void;
    set_value(handle, key_name, DataType::Int8, c_value as *mut c_void, 1)
}

/// Sets a u16 value into cmap
/// handle: handle returned from [initialize]
/// key_name: must be a C-compatible string
/// value u16
pub fn set_u16(handle: Handle, key_name: String, value: u16) -> Result<()>
{
    let mut tmp = value;
    let c_value: *mut c_void = &mut tmp as *mut _ as *mut c_void;
    set_value(handle, key_name, DataType::UInt16, c_value as *mut c_void, 2)
}

/// Sets an i16 value into cmap
/// handle: handle returned from [initialize]
/// key_name: must be a C-compatible string
/// value u16
pub fn set_i16(handle: Handle, key_name: String, value: i16) -> Result<()>
{
    let mut tmp = value;
    let c_value: *mut c_void = &mut tmp as *mut _ as *mut c_void;
    set_value(handle, key_name, DataType::Int16, c_value as *mut c_void, 2)
}

/// Sets a u32 value into cmap
/// handle: handle returned from [initialize]
/// key_name: must be a C-compatible string
/// value u32
pub fn set_u32(handle: Handle, key_name: String, value: u32) -> Result<()>
{
    let mut tmp = value;
    let c_value: *mut c_void = &mut tmp as *mut _ as *mut c_void;
    set_value(handle, key_name, DataType::UInt32, c_value, 4)
}

/// Sets an i32 value into cmap
/// handle: handle returned from [initialize]
/// key_name: must be a C-compatible string
/// value u32
pub fn set_i132(handle: Handle, key_name: String, value: i32) -> Result<()>
{
    let mut tmp = value;
    let c_value: *mut c_void = &mut tmp as *mut _ as *mut c_void;
    set_value(handle, key_name, DataType::Int32, c_value as *mut c_void, 4)
}

/// Sets a u64 value into cmap
/// handle: handle returned from [initialize]
/// key_name: must be a C-compatible string
/// value u64
pub fn set_u64(handle: Handle, key_name: String, value: u64) -> Result<()>
{
    let mut tmp = value;
    let c_value: *mut c_void = &mut tmp as *mut _ as *mut c_void;
    set_value(handle, key_name, DataType::UInt64, c_value as *mut c_void, 8)
}

/// Sets an i64 value into cmap
/// handle: handle returned from [initialize]
/// key_name: must be a C-compatible string
/// value u64
pub fn set_i164(handle: Handle, key_name: String, value: i64) -> Result<()>
{
    let mut tmp = value;
    let c_value: *mut c_void = &mut tmp as *mut _ as *mut c_void;
    set_value(handle, key_name, DataType::Int64, c_value as *mut c_void, 8)
}

/// Sets a string value into cmap
/// handle: handle returned from [initialize]
/// key_name: must be a C-compatible string
/// value: String, but must also be C-compatible
pub fn set_string(handle: Handle, key_name: String, value: String) -> Result<()>
{
    let v_string =  string_to_cstring_validated(&value, 0)?;
    set_value(handle, key_name, DataType::String, v_string.as_ptr() as *mut c_void, value.len())
}

/// Sets a binary value into cmap
/// handle: handle returned from [initialize]
/// key_name: must be a C-compatible string
/// value: &[u8] of any length
pub fn set_binary(handle: Handle, key_name: String, value: &[u8]) -> Result<()>
{
    set_value(handle, key_name, DataType::String, value.as_ptr() as *mut c_void, value.len())
}


/// cmap_get: get a value from cmap
/// handle: cmap handle from [initialize]
/// key_name: String name for the cmap key
/// returns a [Data] enum with the value
const INITIAL_SIZE : usize = 256;
pub fn get(handle: Handle, key_name: String) -> Result<Data>
{
    let csname = string_to_cstring_validated(&key_name, CMAP_KEYNAME_MAXLENGTH)?;
    let mut value_size : usize = 16;
    let mut c_key_type : u32 = 0;
    let mut c_value = [0u8; INITIAL_SIZE];

    unsafe {
	let res = ffi::cmap::cmap_get(handle.cmap_handle, csname.as_ptr(), c_value.as_mut_ptr() as *mut c_void, &mut value_size, &mut c_key_type);

	if res == ffi::cmap::CS_OK {
	    match cmap_to_enum(c_key_type) {
		DataType::UInt8 => {
		    let mut ints = [0u8; 1];
		    copy_nonoverlapping(c_value.as_ptr() as *mut u8, ints.as_mut_ptr() as *mut u8, value_size);
		    Ok(Data::UInt8(ints[0]))
		}
		DataType::Int8 => {
		    let mut ints = [0i8; 1];
		    copy_nonoverlapping(c_value.as_ptr() as *mut u8, ints.as_mut_ptr() as *mut u8, value_size);
		    Ok(Data::Int8(ints[0]))
		}
		DataType::UInt16 => {
		    let mut ints = [0u16; 1];
		    copy_nonoverlapping(c_value.as_ptr() as *mut u8, ints.as_mut_ptr() as *mut u8, value_size);
		    Ok(Data::UInt16(ints[0]))
		}
		DataType::Int16 => {
		    let mut ints = [0i16; 1];
		    copy_nonoverlapping(c_value.as_ptr() as *mut u8, ints.as_mut_ptr() as *mut u8, value_size);
		    Ok(Data::Int16(ints[0]))
		}
		DataType::UInt32 => {
		    let mut ints = [0u32; 1];
		    copy_nonoverlapping(c_value.as_ptr() as *mut u8, ints.as_mut_ptr() as *mut u8, value_size);
		    Ok(Data::UInt32(ints[0]))
		}
		DataType::Int32 => {
		    let mut ints = [0i32; 1];
		    copy_nonoverlapping(c_value.as_ptr() as *mut u8, ints.as_mut_ptr() as *mut u8, value_size);
		    Ok(Data::Int32(ints[0]))
		}
		DataType::UInt64 => {
		    let mut ints = [0u64; 1];
		    copy_nonoverlapping(c_value.as_ptr() as *mut u8, ints.as_mut_ptr() as *mut u8, value_size);
		    Ok(Data::UInt64(ints[0]))
		}
		DataType::Int64 => {
		    let mut ints = [0i64; 1];
		    copy_nonoverlapping(c_value.as_ptr() as *mut u8, ints.as_mut_ptr() as *mut u8, value_size);
		    Ok(Data::Int64(ints[0]))
		}
		DataType::Float => {
		    let mut ints = [0f32; 1];
		    copy_nonoverlapping(c_value.as_ptr() as *mut u8, ints.as_mut_ptr() as *mut u8, value_size);
		    Ok(Data::Float(ints[0]))
		}
		DataType::Double => {
		    let mut ints = [0f64; 1];
		    copy_nonoverlapping(c_value.as_ptr() as *mut u8, ints.as_mut_ptr() as *mut u8, value_size);
		    Ok(Data::Double(ints[0]))
		}
		DataType::String => {
		    let mut ints = Vec::<u8>::new();

		    // Too big - get it again
		    if value_size > INITIAL_SIZE {
			ints.resize(value_size, 0u8);
			let res = ffi::cmap::cmap_get(handle.cmap_handle, csname.as_ptr(), ints.as_mut_ptr() as *mut c_void, &mut value_size, &mut c_key_type);
			if res != ffi::cmap::CS_OK {
			    return Err(cs_error_to_enum(res));
			}
		    } else {
			ints.resize(value_size, 0u8);
			copy_nonoverlapping(c_value.as_ptr() as *mut u8, ints.as_mut_ptr() as *mut u8, value_size);
		    }
		    // -1 here so CString doesn't see the NUL
		    let cs = match CString::new(&ints[0..value_size-1 as usize]) {
			Ok(c1) => c1,
			Err(_) => return Err(CsError::CsErrLibrary),
		    };
		    match cs.into_string() {
			Ok(s) => Ok(Data::String(s)),
			Err(_) => return Err(CsError::CsErrLibrary),
		    }
		}
		DataType::Binary => {
		    let mut ints = Vec::<u8>::new();
		    // Too big - get it again
		    if value_size > INITIAL_SIZE {
			ints.resize(value_size, 0u8);
			let res = ffi::cmap::cmap_get(handle.cmap_handle, csname.as_ptr(), ints.as_mut_ptr() as *mut c_void, &mut value_size, &mut c_key_type);
			if res != ffi::cmap::CS_OK {
			    return Err(cs_error_to_enum(res));
			}
		    } else {
			ints.resize(value_size, 0u8);
			copy_nonoverlapping(c_value.as_ptr() as *mut u8, ints.as_mut_ptr() as *mut u8, value_size);
		    }
		    Ok(Data::Binary(ints))
		}
		DataType::Unknown => {
		    Ok(Data::Unknown)
		}
	    }
	} else {
	    return Err(cs_error_to_enum(res));
	}
    }
}

/// increment the value in a cmap key (must be a numeric type)
/// handle: a cmap handle as returned from [initialize]
/// key_name:Name of the key whose value is to be incremented
pub fn inc(handle: Handle, key_name: String) -> Result<()>
{
    let csname = string_to_cstring_validated(&key_name, CMAP_KEYNAME_MAXLENGTH)?;
    let res = unsafe {
	ffi::cmap::cmap_inc(handle.cmap_handle, csname.as_ptr())
    };
    if res == ffi::cmap::CS_OK {
	Ok(())
    } else {
	Err(cs_error_to_enum(res))
    }
}

/// decrement the value in a cmap key (must be a numeric type)
/// handle: a cmap handle as returned from [initialize]
/// key_name:Name of the key whose value is to be decremented
pub fn dec(handle: Handle, key_name: String) -> Result<()>
{
    let csname = string_to_cstring_validated(&key_name, CMAP_KEYNAME_MAXLENGTH)?;
    let res = unsafe {
	ffi::cmap::cmap_dec(handle.cmap_handle, csname.as_ptr())
    };
    if res == ffi::cmap::CS_OK {
	Ok(())
    } else {
	Err(cs_error_to_enum(res))
    }
}
